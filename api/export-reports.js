import ExcelJS from 'exceljs'
import PDFDocument from 'pdfkit'

export default async function handler(req, res) {
  if (req.method === 'OPTIONS') return res.status(200).end()

  if (req.method !== 'POST') {
    return res.status(405).json({ success: false, error: 'Method not allowed' })
  }

  try {
    const { type, data, format, department, generatedBy, generatedAt, metadata } = req.body

    if (!type || !data || !format) {
      return res.status(400).json({ success: false, error: 'Missing required fields' })
    }

    const filename = `${type}_${department}_${new Date().toISOString().split('T')[0]}`

    switch (format.toLowerCase()) {
      case 'pdf':
        await generatePDF(res, { type, data, metadata, filename, generatedBy, generatedAt })
        return
      case 'excel':
        await generateExcel(res, { type, data, metadata, filename, generatedBy, generatedAt })
        return
      case 'csv':
        await generateCSV(res, { type, data, metadata, filename, generatedBy, generatedAt })
        return
      default:
        return res.status(400).json({ success: false, error: 'Unsupported format' })
    }
  } catch (error) {
    console.error('Export error:', error)
    return res.status(500).json({ success: false, error: 'Export failed' })
  }
}

async function generatePDF(res, { type, data, metadata, filename, generatedBy, generatedAt }) {
  const doc = new PDFDocument({ margin: 50 })
  
  res.setHeader('Content-Type', 'application/pdf')
  res.setHeader('Content-Disposition', `attachment; filename="${filename}.pdf"`)
  
  doc.pipe(res)

  // Header
  doc.fontSize(20).text(metadata.reportTitle, { align: 'center' })
  doc.fontSize(12).text(`Department: ${metadata.departmentName}`, { align: 'center' })
  doc.fontSize(10).text(`Generated by: ${generatedBy} on ${new Date(generatedAt).toLocaleString()}`, { align: 'center' })
  doc.moveDown(2)

  switch (type) {
    case 'department-summary':
      generateDepartmentSummaryPDF(doc, data)
      break
    case 'classwise-performance':
      generateClasswisePerformancePDF(doc, data)
      break
    case 'failed-dispatches':
      generateFailedDispatchesPDF(doc, data)
      break
    case 'subject-analysis':
      generateSubjectAnalysisPDF(doc, data)
      break
  }

  doc.end()
}

function normalizeClasswiseData(data) {
  if (!data) return []
  if (Array.isArray(data)) return data
  if (typeof data === 'object') {
    return Object.entries(data).map(([classKey, value]) => ({
      classKey,
      ...value
    }))
  }
  return []
}

function normalizeSubjectData(data) {
  if (!data) return []
  if (Array.isArray(data)) return data
  if (typeof data === 'object') {
    return Object.entries(data).map(([subjectKey, value]) => ({
      subjectName: value?.subjectName || subjectKey,
      subjectCode: value?.subjectCode || value?.code || 'N/A',
      ...value
    }))
  }
  return []
}

function drawCard(doc, { x, y, width, height, title, value, icon, iconColor }) {
  doc.save()
  doc.roundedRect(x, y, width, height, 12)
    .fillOpacity(1)
    .fill('#ffffff')
  doc.lineWidth(1).strokeColor('#f4efe5').roundedRect(x, y, width, height, 12).stroke()
  doc.fillColor('#a1a1aa').fontSize(11).text(title, x + 16, y + 14, { width: width - 32 })
  if (icon) {
    doc.circle(x + width - 26, y + 18, 10).fill(iconColor || '#fbbf24')
    doc.fillColor('#ffffff').fontSize(12).text(icon, x + width - 31, y + 11)
  }
  doc.fillColor('#111827').fontSize(22).font('Helvetica-Bold')
    .text(value, x + 16, y + 34)
  doc.restore()
}

function renderListSection(doc, { title, data = [], colors = {} }) {
  const startY = doc.y
  doc.save()
  doc.roundedRect(doc.page.margins.left, startY, doc.page.width - doc.page.margins.left - doc.page.margins.right, 20, 10)
    .fillOpacity(1).fill('#fff8ee')
  doc.fillColor('#c084fc').fontSize(13).font('Helvetica-Bold')
    .text(title, doc.page.margins.left + 16, startY + 4)
  doc.restore()
  doc.moveDown(1.4)
  data.forEach(item => {
    doc.circle(doc.page.margins.left + 10, doc.y + 8, 3).fill(colors.dot || '#f59e0b')
    doc.fillColor('#111827').fontSize(12).text(item.label, doc.page.margins.left + 24, doc.y, { continued: true })
    doc.fillColor('#4338ca').text(item.value, { align: 'right' })
  })
  doc.moveDown()
}

function generateDepartmentSummaryPDF(doc, data) {
  doc.font('Helvetica-Bold').fontSize(16).fillColor('#111827').text('Department Summary', { align: 'left' })
  doc.moveDown(0.3)
  doc.font('Helvetica').fontSize(11).fillColor('#6b7280').text(`Generated on ${new Date().toLocaleString()}`)
  doc.moveDown(1)

  const cardWidth = (doc.page.width - doc.page.margins.left - doc.page.margins.right - 30) / 4
  const cardHeight = 70
  const statuses = [
    { title: 'Total', value: data.totalStudents || 0, icon: 'â—', color: '#f97316' },
    { title: 'Dispatched', value: data.byStatus?.dispatched || 0, icon: 'âœ“', color: '#10b981' },
    { title: 'Pending', value: data.byStatus?.pending || 0, icon: 'â±', color: '#fbbf24' },
    { title: 'Rejected', value: data.byStatus?.rejected || 0, icon: 'âœ•', color: '#ef4444' }
  ]
  let currentX = doc.page.margins.left
  const cardY = doc.y
  statuses.forEach((card) => {
    drawCard(doc, {
      x: currentX,
      y: cardY,
      width: cardWidth,
      height: cardHeight,
      title: card.title,
      value: card.value,
      icon: card.icon,
      iconColor: card.color
    })
    currentX += cardWidth + 10
  })
  doc.y = cardY + cardHeight + 25

  if (Array.isArray(data.yearWiseBreakdown) && data.yearWiseBreakdown.length > 0) {
    const yearList = data.yearWiseBreakdown.map(year => ({
      label: `Year ${year._id}`,
      value: year.count
    }))
    renderListSection(doc, { title: 'Year-wise Distribution', data: yearList, colors: { dot: '#f97316' } })
  }

  const overallResults = data.overallResults || data.overallGrades || {}
  if (overallResults && Object.keys(overallResults).length > 0) {
    const resultList = Object.entries(overallResults).map(([result, count]) => ({
      label: `Result ${result}`,
      value: count
    }))
    renderListSection(doc, { title: 'Result Distribution', data: resultList, colors: { dot: '#a855f7' } })
  }
}

function generateClasswisePerformancePDF(doc, rawData) {
  const data = normalizeClasswiseData(rawData)
  if (data.length === 0) {
    doc.text('No classwise performance data available.')
    return
  }

  doc.font('Helvetica-Bold').fontSize(16).fillColor('#111827').text('Class-wise Performance', { align: 'left' })
  doc.moveDown(0.3)
  doc.font('Helvetica').fontSize(11).fillColor('#6b7280').text(`Generated on ${new Date().toLocaleString()}`)
  doc.moveDown(1)

  data.forEach(classData => {
    const cardWidth = doc.page.width - doc.page.margins.left - doc.page.margins.right
    const cardHeight = 110
    const startY = doc.y
    doc.save()
    doc.roundedRect(doc.page.margins.left, startY, cardWidth, cardHeight, 18)
      .fillOpacity(1).fill('#ffffff')
    doc.lineWidth(1).strokeColor('#f1f5f9').roundedRect(doc.page.margins.left, startY, cardWidth, cardHeight, 18).stroke()

    const classLabel = classData.classKey || `${classData.branch || 'Class'} ${classData.section || ''}`
    doc.fillColor('#16a34a').fontSize(11).text('ğŸ«', doc.page.margins.left + 18, startY + 18)
    doc.fillColor('#111827').fontSize(13).font('Helvetica-Bold')
      .text(classLabel, doc.page.margins.left + 40, startY + 16, { width: cardWidth / 2 })
    doc.fillColor('#6b7280').font('Helvetica').fontSize(11)
      .text(`Year ${classData.year || '-'}` + (classData.section ? ` â€¢ Section ${classData.section}` : ''), doc.page.margins.left + 40, startY + 33)

    doc.fillColor('#22c55e').fontSize(10).text(`${classData.totalStudents} Students`, doc.page.margins.left + cardWidth - 140, startY + 18)
    doc.fillColor('#f59e0b').text(`${classData.dispatchRate}% Dispatched`, doc.page.margins.left + cardWidth - 140, startY + 32)

    const metricsY = startY + 60
    const metrics = [
      { label: 'Total', value: classData.totalStudents, color: '#10b981' },
      { label: 'Dispatched', value: classData.dispatched, color: '#2563eb' },
      { label: 'Pending', value: classData.pending, color: '#f59e0b' }
    ]
    let metricX = doc.page.margins.left + 20
    metrics.forEach(metric => {
      doc.fillColor('#6b7280').fontSize(10).text(metric.label, metricX, metricsY)
      doc.fillColor(metric.color).fontSize(16).font('Helvetica-Bold').text(metric.value, metricX, metricsY + 12)
      metricX += 110
    })

    const classResults = classData.resultDistribution || classData.gradeDistribution || {}
    if (classResults && Object.keys(classResults).length > 0) {
      doc.fillColor('#9333ea').font('Helvetica-Bold').fontSize(11)
        .text('Result Distribution', doc.page.margins.left + cardWidth - 200, metricsY)
      doc.font('Helvetica').fontSize(10).fillColor('#4c1d95')
      Object.entries(classResults).forEach(([result, count], idx) => {
        doc.text(`${result}: ${count}`, doc.page.margins.left + cardWidth - 200, metricsY + 14 + (idx * 12))
      })
    }

    doc.restore()
    doc.moveDown(4)
  })
}

function generateFailedDispatchesPDF(doc, data = []) {
  const list = Array.isArray(data) ? data : []
  doc.fontSize(14).text('Failed Dispatches Report', { underline: true })
  doc.moveDown()

  if (list.length === 0) {
    doc.text('No failed dispatches found.')
    return
  }

  list.forEach((marksheet, index) => {
    doc.fontSize(10)
    doc.text(`${index + 1}. ${marksheet.studentName} (${marksheet.registerNumber})`)
    doc.text(`   Branch: ${marksheet.branch}, Year: ${marksheet.year}`)
    doc.text(`   Attempts: ${marksheet.dispatchAttempts}`)
    doc.text(`   Last Attempt: ${new Date(marksheet.lastDispatchAttempt).toLocaleDateString()}`)
    doc.moveDown(0.3)
  })
}

function generateSubjectAnalysisPDF(doc, data = []) {
  const list = normalizeSubjectData(data)
  doc.font('Helvetica-Bold').fontSize(16).fillColor('#111827').text('Subject Analysis', { align: 'left' })
  doc.moveDown(0.3)
  doc.font('Helvetica').fontSize(11).fillColor('#6b7280').text(`Generated on ${new Date().toLocaleString()}`)
  doc.moveDown(1)

  if (list.length === 0) {
    doc.text('No subject analysis data available.')
    return
  }

  list.forEach(subject => {
    const cardWidth = doc.page.width - doc.page.margins.left - doc.page.margins.right
    const cardHeight = 100
    const startY = doc.y

    doc.save()
    doc.roundedRect(doc.page.margins.left, startY, cardWidth, cardHeight, 16)
      .fillOpacity(1).fill('#ffffff')
    doc.lineWidth(1).strokeColor('#ede9fe').roundedRect(doc.page.margins.left, startY, cardWidth, cardHeight, 16).stroke()

    doc.fillColor('#a855f7').fontSize(13).text('ğŸ“˜', doc.page.margins.left + 16, startY + 18)
    doc.fillColor('#111827').font('Helvetica-Bold').fontSize(13)
      .text(subject.subjectName, doc.page.margins.left + 40, startY + 16, { width: cardWidth / 2 })
    doc.font('Helvetica').fontSize(10).fillColor('#6b7280')
      .text(`Subject Code: ${subject.subjectCode || 'N/A'}`, doc.page.margins.left + 40, startY + 34)

    doc.fillColor('#d946ef').fontSize(10).text(`${subject.totalEnrollments || 0} Students`, doc.page.margins.left + cardWidth - 130, startY + 22)

    const avgValue = typeof subject.average === 'number'
      ? subject.average.toFixed(1)
      : (subject.average ?? subject.averageMarks ?? '-')

    const passRateRaw = subject.passingRate ?? subject.passRate ?? 0
    const passRate = typeof passRateRaw === 'number'
      ? passRateRaw.toFixed(1)
      : passRateRaw

    const metrics = [
      { label: 'Average', value: avgValue, color: '#6366f1' },
      { label: 'Highest', value: subject.highest ?? '-', color: '#16a34a' },
      { label: 'Lowest', value: subject.lowest ?? '-', color: '#dc2626' },
      { label: 'Pass Rate', value: `${passRate}%`, color: '#f59e0b' }
    ]

    let metricX = doc.page.margins.left + 30
    const metricY = startY + 60
    metrics.forEach(metric => {
      doc.fillColor('#6b7280').fontSize(10).text(metric.label, metricX, metricY)
      doc.fillColor(metric.color).font('Helvetica-Bold').fontSize(14).text(metric.value, metricX, metricY + 12)
      metricX += 120
    })

    doc.restore()
    doc.moveDown(3.5)
  })
}

async function generateExcel(res, { type, data, metadata, filename, generatedBy, generatedAt }) {
  const workbook = new ExcelJS.Workbook()
  const worksheet = workbook.addWorksheet('Report')

  res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
  res.setHeader('Content-Disposition', `attachment; filename="${filename}.xlsx"`)

  // Header styling
  const headerStyle = {
    font: { bold: true, size: 14 },
    alignment: { horizontal: 'center' },
    fill: { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE6E6FA' } }
  }

  // Add title
  worksheet.addRow([metadata.reportTitle])
  worksheet.getRow(1).font = { bold: true, size: 16 }
  worksheet.getRow(1).alignment = { horizontal: 'center' }

  worksheet.addRow([`Department: ${metadata.departmentName}`])
  worksheet.addRow([`Generated by: ${generatedBy} on ${new Date(generatedAt).toLocaleString()}`])
  worksheet.addRow([]) // Empty row

  switch (type) {
    case 'department-summary':
      generateDepartmentSummaryExcel(worksheet, data, headerStyle)
      break
    case 'classwise-performance':
      generateClasswisePerformanceExcel(worksheet, data, headerStyle)
      break
    case 'failed-dispatches':
      generateFailedDispatchesExcel(worksheet, data, headerStyle)
      break
    case 'subject-analysis':
      generateSubjectAnalysisExcel(worksheet, data, headerStyle)
      break
  }

  // Auto-fit columns
  worksheet.columns.forEach(column => {
    column.width = Math.max(10, column.width || 0)
  })

  await workbook.xlsx.write(res)
  res.end()
}

function generateDepartmentSummaryExcel(worksheet, data, headerStyle) {
  worksheet.addRow(['Summary Statistics'])
  worksheet.getRow(worksheet.rowCount).style = headerStyle

  worksheet.addRow(['Metric', 'Count'])
  worksheet.addRow(['Total Students', data.totalStudents])
  worksheet.addRow(['Total Marksheets', data.totalMarksheets])
  worksheet.addRow(['Dispatched', data.dispatched])
  worksheet.addRow(['Pending', data.pending])
  worksheet.addRow(['Failed', data.failed])

  if (data.yearWiseBreakdown && data.yearWiseBreakdown.length > 0) {
    worksheet.addRow([])
    worksheet.addRow(['Year-wise Breakdown'])
    worksheet.getRow(worksheet.rowCount).style = headerStyle
    
    worksheet.addRow(['Year', 'Students', 'Marksheets'])
    data.yearWiseBreakdown.forEach(year => {
      worksheet.addRow([year._id, year.count, year.marksheets])
    })
  }
}

function generateClasswisePerformanceExcel(worksheet, rawData, headerStyle) {
  const data = normalizeClasswiseData(rawData)
  worksheet.addRow(['Branch', 'Year', 'Total Students', 'Dispatched', 'Pending', 'Dispatch Rate (%)'])
  worksheet.getRow(worksheet.rowCount).style = headerStyle

  if (data.length === 0) {
    worksheet.addRow(['N/A', 'N/A', 0, 0, 0, 0])
    return
  }

  data.forEach(classData => {
    worksheet.addRow([
      classData.branch || classData.classKey || 'Class',
      classData.year || 'â€”',
      classData.totalStudents,
      classData.dispatched,
      classData.pending,
      classData.dispatchRate
    ])
  })
}

function generateFailedDispatchesExcel(worksheet, data, headerStyle) {
  const list = Array.isArray(data) ? data : []
  if (list.length === 0) {
    worksheet.addRow(['No failed dispatches found'])
    return
  }

  worksheet.addRow(['Student Name', 'Register Number', 'Branch', 'Year', 'Attempts', 'Last Attempt'])
  worksheet.getRow(worksheet.rowCount).style = headerStyle

  list.forEach(marksheet => {
    worksheet.addRow([
      marksheet.studentName,
      marksheet.registerNumber,
      marksheet.branch,
      marksheet.year,
      marksheet.dispatchAttempts,
      new Date(marksheet.lastDispatchAttempt).toLocaleDateString()
    ])
  })
}

function generateSubjectAnalysisExcel(worksheet, data, headerStyle) {
  const list = normalizeSubjectData(data)
  worksheet.addRow(['Subject Name', 'Subject Code', 'Total Enrollments', 'Pass Rate (%)', 'Average Marks'])
  worksheet.getRow(worksheet.rowCount).style = headerStyle

  if (list.length === 0) {
    worksheet.addRow(['No subject data available'])
    return
  }

  list.forEach(subject => {
    const averageMarksValue = typeof subject.average === 'number'
      ? subject.average.toFixed(1)
      : (subject.average ?? subject.averageMarks ?? '-')

    worksheet.addRow([
      subject.subjectName,
      subject.subjectCode,
      subject.totalEnrollments,
      subject.passRate,
      averageMarksValue
    ])
  })
}

async function generateCSV(res, { type, data, metadata, filename, generatedBy, generatedAt }) {
  res.setHeader('Content-Type', 'text/csv')
  res.setHeader('Content-Disposition', `attachment; filename="${filename}.csv"`)

  let csvContent = `${metadata.reportTitle}\n`
  csvContent += `Department: ${metadata.departmentName}\n`
  csvContent += `Generated by: ${generatedBy} on ${new Date(generatedAt).toLocaleString()}\n\n`

  switch (type) {
    case 'department-summary':
      csvContent += generateDepartmentSummaryCSV(data)
      break
    case 'classwise-performance':
      csvContent += generateClasswisePerformanceCSV(data)
      break
    case 'failed-dispatches':
      csvContent += generateFailedDispatchesCSV(data)
      break
    case 'subject-analysis':
      csvContent += generateSubjectAnalysisCSV(data)
      break
  }

  res.send(csvContent)
}

function generateDepartmentSummaryCSV(data) {
  let csv = 'Summary Statistics\n'
  csv += 'Metric,Count\n'
  csv += `Total Students,${data.totalStudents}\n`
  csv += `Total Marksheets,${data.totalMarksheets}\n`
  csv += `Dispatched,${data.dispatched}\n`
  csv += `Pending,${data.pending}\n`
  csv += `Failed,${data.failed}\n\n`

  if (data.yearWiseBreakdown && data.yearWiseBreakdown.length > 0) {
    csv += 'Year-wise Breakdown\n'
    csv += 'Year,Students,Marksheets\n'
    data.yearWiseBreakdown.forEach(year => {
      csv += `${year._id},${year.count},${year.marksheets}\n`
    })
  }

  return csv
}

function generateClasswisePerformanceCSV(rawData) {
  const data = normalizeClasswiseData(rawData)
  let csv = 'Branch,Year,Total Students,Dispatched,Pending,Dispatch Rate (%)\n'
  
  if (data.length === 0) {
    csv += 'N/A,N/A,0,0,0,0\n'
    return csv
  }

  data.forEach(classData => {
    csv += `"${classData.branch || classData.classKey}",${classData.year || ''},${classData.totalStudents},${classData.dispatched},${classData.pending},${classData.dispatchRate}\n`
  })

  return csv
}

function generateFailedDispatchesCSV(data) {
  if (data.length === 0) {
    return 'No failed dispatches found\n'
  }

  let csv = 'Student Name,Register Number,Branch,Year,Attempts,Last Attempt\n'
  
  data.forEach(marksheet => {
    csv += `"${marksheet.studentName}","${marksheet.registerNumber}","${marksheet.branch}",${marksheet.year},${marksheet.dispatchAttempts},"${new Date(marksheet.lastDispatchAttempt).toLocaleDateString()}"\n`
  })

  return csv
}

function generateSubjectAnalysisCSV(data) {
  const list = normalizeSubjectData(data)
  let csv = 'Subject Name,Subject Code,Total Enrollments,Pass Rate (%),Average Marks\n'
  
  if (list.length === 0) {
    csv += 'N/A,N/A,0,0,0\n'
    return csv
  }

  list.forEach(subject => {
    const averageMarksValue = typeof subject.average === 'number'
      ? subject.average.toFixed(1)
      : (subject.average ?? subject.averageMarks ?? subject.averageGrade ?? '-')

    csv += `"${subject.subjectName}","${subject.subjectCode}",${subject.totalEnrollments},${subject.passRate},"${averageMarksValue}"\n`
  })

  return csv
}